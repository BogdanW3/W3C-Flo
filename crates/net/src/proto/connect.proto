syntax = "proto3";
package flo_connect;

import "google/protobuf/wrappers.proto";
import "proto/common.proto";

message PacketConnectLobby {
  flo_common.Version connect_version = 1;
  string token = 2;
}

message PacketConnectLobbyAccept {
  flo_common.Version lobby_version = 1;
  Session session = 2;
  repeated Node nodes = 3;
}

enum ConnectLobbyRejectReason {
  ConnectLobbyRejectReasonUnknown = 0;
  ConnectLobbyRejectReasonClientVersionTooOld = 1;
  ConnectLobbyRejectReasonInvalidToken = 2;
}

message PacketConnectLobbyReject {
  flo_common.Version lobby_version = 1;
  ConnectLobbyRejectReason reason = 2;
}


enum LobbyDisconnectReason {
  LobbyDisconnectReasonUnknown = 0;
  LobbyDisconnectReasonMulti = 1;
  LobbyDisconnectReasonMaintenance = 2;
}

message PacketLobbyDisconnect {
  LobbyDisconnectReason reason = 1;
}

message PacketPlayerSessionUpdate {
  PlayerStatus status = 1;
  google.protobuf.Int32Value game_id = 2;
}

message PacketGameInfo {
  GameInfo game = 1;
}

message PacketGamePlayerEnter {
  int32 game_id = 1;
  int32 slot_index = 2;
  Slot slot = 3;
}

message PacketGamePlayerLeave {
  int32 game_id = 1;
  int32 player_id = 2;
  PlayerLeaveReason reason = 3;
}

message PacketGameSlotUpdateRequest {
  int32 game_id = 1;
  flo_common.SlotSettings slot_settings = 3;
}

message PacketGameSlotUpdate {
  int32 game_id = 1;
  int32 slot_index = 2;
  flo_common.SlotSettings slot_settings = 3;
}

message PacketListNodesRequest {}

message PacketListNodes {
  repeated Node nodes = 1;
}

message PacketGameSelectNodeRequest {
  int32 game_id = 1;
  google.protobuf.Int32Value node_id = 2;
}

message PacketGameSelectNode {
  int32 game_id = 1;
  google.protobuf.Int32Value node_id = 2;
}

message PacketGamePlayerPingMapUpdateRequest {
  int32 game_id = 1;
  map<int32, uint32> ping_map = 2;
}

message PacketGamePlayerPingMapUpdate {
  int32 game_id = 1;
  int32 player_id = 2;
  map<int32, uint32> ping_map = 3;
}

message PacketGamePlayerPingMapSnapshotRequest {
  int32 game_id = 1;
}

message PacketGamePlayerPingMapSnapshot {
  int32 game_id = 1;
  map<int32, NodePingMap> node_ping_map = 2;
}

message PacketGamePlayerToken {
  int32 node_id = 1;
  int32 game_id = 2;
  bytes player_token = 3;
}

message PacketGameStartRequest {
  int32 game_id = 1;
}

message PacketGameStarting {
  int32 game_id = 1;
}

message PacketGameStartReject {
  int32 game_id = 1;
  string message = 2;
  map<int32, PacketGameStartPlayerClientInfoRequest> player_client_info_map = 3;
}

message PacketGameStartPlayerClientInfoRequest {
  int32 game_id = 1;
  string war3_version = 2;
  bytes map_sha1 = 3;
}

message NodePingMap {
  map<int32, uint32> player_ping_map = 2;
}

message Node {
  int32 id = 1;
  string name = 2;
  string location = 3;
  string ip_addr = 4;
  string country_id = 5;
}

enum PlayerSource {
  PlayerSourceTest = 0;
  PlayerSourceBNet = 1;
}

message PlayerInfo {
  int32 id = 1;
  string name = 2;
  PlayerSource source = 3;
  google.protobuf.StringValue realm = 4;
}

enum PlayerStatus {
  PlayerStatusIdle = 0;
  PlayerStatusInGame = 1;
}

message Session {
  PlayerInfo player = 1;
  PlayerStatus status = 2;
  google.protobuf.Int32Value game_id = 3;
}

message GameInfo {
  int32 id = 1;
  string name = 2;
  GameStatus status = 3;
  Map map = 4;
  repeated Slot slots = 5;
  SelectedNode node = 6;
  bool is_private = 7;
  bool is_live = 9;
  PlayerInfo created_by = 12;
}

message SelectedNode {
  SelectedNodeType type = 1;
  google.protobuf.Int32Value id = 2;
  string name = 3;
  string location = 4;
  string ip_addr = 5;
  string country_id = 6;
  // for private node type
  google.protobuf.StringValue secret = 7;
}

enum SelectedNodeType {
  SelectedNodeTypePublic = 0;
  SelectedNodeTypePrivate = 1;
}

message Slot {
  PlayerInfo player = 1;
  flo_common.SlotSettings settings = 2;
}

message Map {
  bytes sha1 = 1;
  uint32 checksum = 2;
  string path = 3;
}

enum GameStatus {
  GameStatusPreparing = 0;
  GameStatusCreated = 1;
  GameStatusRunning = 2;
  GameStatusEnded = 3;
  GameStatusPaused = 4;
  GameStatusTerminated = 5;
}

enum PlayerLeaveReason {
  PlayerLeaveReasonLeft = 0;
  PlayerLeaveReasonKicked = 1;
  PlayerLeaveReasonGameCancelled = 2;
}

enum GameStartRejectReason {
  GameStartRejectReasonWar3Version = 0;
  GameStartRejectReasonMapSha1 = 1;
}